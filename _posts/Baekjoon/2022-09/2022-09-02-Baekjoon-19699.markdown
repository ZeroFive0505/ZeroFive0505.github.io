---
layout: post
title: 소-난다!
date: 2022-09-02 09:23:09 +0900
categories: Baekjoon
---

## 문제 링크 -> [Baekjoon](https://www.acmicpc.net/problem/19699)
# 소-난다!

# 문제
> 지난 번 헛간 청약의 당첨우(牛)가 발표됐다. 청약에 당첨된 소들은 날아갈 듯이 기뻐하다가 진짜로 하늘을 날았다. 하지만 이후로 소들은 날 수 없었다. 그러던 어느 날, 꿀벌에게 쏘이면 잠깐 하늘을 날 수 있다는 사실을 깨달았다. 이 사실이 퍼지자 소들은 다시 자유롭게 하늘을 날기 시작했다.
소들이 하늘을 날며 우(牛)통사고가 빈번해지자, 농부 존은 소들이 하늘을 나는 것에 제한을 두었다. 소들은 항의했지만 소들의 항의는 받아들여지지 않았다.
농장에는 $N$마리의 소가 있다. 농부 존은 소들의 몸무게의 합이 소수(prime)가 되도록 $M$마리의 소를 선별할 계획이다. 농부 존의 계획에 맞게 소를 선별했을 때 나올 수 있는 몸무게의 합을 모두 출력하시오.

# 입력
> 첫째 줄에 농장에 있는 소들의 수 $N$, 선별할 소의 수 $M$이 주어진다.
둘째 줄에 소들의 몸무게 $H_i$가 주어진다.

# 출력
>  $M$마리 소들의 몸무게 합으로 만들 수 있는 모든 소수를 오름차순으로 출력한다. 만약 그러한 경우가 없다면 $-1$을 출력한다.

# 풀이
조합으로 M마리의 소를 선택했을시 소수인지 판별하고 'set'에 집어 넣는다. 이때 'set'이 비어있다면 -1을 출력한다.

# 코드
```c++
#include <iostream>
#include <set>

using namespace std;

const int MAX = 10;

int arr[MAX] = { };
bool selected[MAX] = {};

set<int> ans;

int N, M;

bool IsPrime(int n)
{
	if (n == 1)
		return false;

	for (int i = 2; i * i <= n; i++)
	{
		if (n % i == 0)
			return false;
	}

	return true;
}

void DFS(int sum, int depth)
{
	if (depth >= M)
	{
		if (IsPrime(sum))
			ans.insert(sum);

		return;
	}

	for (int i = 0; i < N; i++)
	{
		if (!selected[i])
		{
			selected[i] = true;
			DFS(sum + arr[i], depth + 1);
			selected[i] = false;
		}
	}
}

int main()
{
	cin >> N >> M;

	for (int i = 0; i < N; i++)
	{
		cin >> arr[i];
	}

	DFS(0, 0);

	if (!ans.empty())
	{
		for (int i : ans)
			cout << i << " ";
	}
	else
		cout << -1 << "\n";


	cout << "\n";

	return 0;
}
```