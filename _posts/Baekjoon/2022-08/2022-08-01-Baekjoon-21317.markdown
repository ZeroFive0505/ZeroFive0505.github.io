---
layout: post
title: 징검다리 건너기
date: 2022-08-01 10:49:49 +0900
categories: Baekjoon
---

## 문제 링크 -> [Baekjoon](https://www.acmicpc.net/problem/21317)
# 징검다리 건너기

# 문제
> 심마니 영재는 산삼을 찾아다닌다.
산삼을 찾던 영재는 N개의 돌이 일렬로 나열되어 있는 강가를 발견했고, 마지막 돌 틈 사이에 산삼이 있다는 사실을 알게 되었다.
마지막 돌 틈 사이에 있는 산삼을 캐기 위해 영재는 돌과 돌 사이를 점프하면서 이동하며 점프의 종류는 3가지가 있다.
점프의 종류에는 현재 위치에서 다음 돌로 이동하는 작은 점프, 1개의 돌을 건너뛰어 이동하는 큰 점프, 2개의 돌을 건너뛰어 이동하는 매우 큰 점프가 있다.
각 점프를 할 때는 에너지를 소비하는데, 이 때 작은 점프와 큰 점프시 소비되는 에너지는 점프를 하는 돌의 번호마다 다르다.
매우 큰 점프는 단 한 번의 기회가 주어지는데, 이때는 점프를 하는 돌의 번호와 상관없이 k만큼의 에너지를 소비한다.
에너지를 최대한 아껴야 하는 영재가 산삼을 얻기 위해 필요한 에너지의 최솟값을 구하여라.
영재는 첫 번째 돌에서부터 출발한다.

# 입력
> 첫 번째 줄에는 돌의 개수 N이 주어진다.
N - 1개의 줄에 걸쳐서, 1번 돌부터 N - 1번 돌 까지의 작은 점프를 하기 위해 필요한 에너지, 큰 점프를 하기 위해 필요한 에너지가 주어진다.
마지막 줄에는 K가 주어진다.

# 출력
> 산삼을 얻기 위해 필요한 영재의 최소 에너지를 출력한다.

# 제한
> - 1 ≤ N ≤ 20
> - 작은 점프, 큰 점프 시 필요한 에너지와 K는 5,000을 넘지않는 자연수이다.

# 풀이
N의 돌이 있을때 N - 1개의 돌에 도달하면된다. 처음에는 N개의 돌에 도달해도 된다고 생각했는데 그렇게 하면 오답 처리가 되서 범위를 조정하니 정답 판정을 받을 수 있었다.

# 코드
```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int INF = 987654321;

const int MAX = 21;

pair<int, int> arr[MAX] = {};

int ans = INF;

int N;

int K;

void DFS(int depth, int e, int jump)
{
    // N - 1번째 돌에 도달
	if (depth >= N - 1)
	{
		ans = min(ans, e);

		return;
	}

    // 한칸 이동
	if(depth + 1 < N)
		DFS(depth + 1, e + arr[depth].first, jump);

    // 두칸 이동
	if(depth + 2 < N)
		DFS(depth + 2, e + arr[depth].second, jump);

    // 점프
	if (jump == 1 && depth + 3 < N)
		DFS(depth + 3, e + K, jump - 1);
}

int main()
{
	cin >> N;

	for (int i = 0; i < N - 1; i++)
	{
		cin >> arr[i].first;
		cin >> arr[i].second;
	}

	cin >> K;

	DFS(0, 0, 1);

	cout << ans << "\n";

	return 0;
}
```