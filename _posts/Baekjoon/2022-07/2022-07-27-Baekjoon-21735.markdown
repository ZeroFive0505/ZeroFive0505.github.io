---
layout: post
title: 눈덩이 굴리기
date: 2022-07-27 07:47:01 +0900
categories: Baekjoon
---

## 문제 링크 -> [Baekjoon](https://www.acmicpc.net/problem/21735)
# 눈덩이 굴리기

# 문제
> 눈송이들이 많은 동네인 숙명여대 앞마당에서 눈사람 만들기 대회를 연다. 앞마당의 길이는 $N$이고 위치 $1$부터 위치 $N$ 까지만 눈이 쌓여있다. 위치 $i$에 눈이 $a_i$만큼 쌓여있다. 대회 규칙은 해당 앞마당에서 $M$초 동안 눈덩이를 굴려 눈사람을 만드는 것이다. 눈덩이의 시작 크기는 $1$이다. 눈덩이의 시작 위치는 $0$이다.
가장 큰 눈사람을 만들고 싶던 수수는 눈덩이를 굴리는 법을 연구했다. 눈덩이를 굴리는 방법에는 두 가지가 있다. 눈덩이를 굴리거나 던질 때 1초가 소모된다.
> 1. 눈덩이를 현재 위치 +1칸으로 굴린다. 현재 칸의 위치를 $i$라고 하면 눈덩이의 크기는 $a_{i+1}$ 만큼 늘어난다.
> 2. 눈덩이를 현재 위치 +2칸으로 던진다. 눈덩이가 착지하며 충격을 받아 눈덩이의 크기는 원래의 크기의 반으로 줄어들고  현재 칸의 위치를 $i$라고 하면 눈덩이의 크기는 $a_{i+2}$ 만큼 늘어난다. 이 때 소수점은 절사한다. 눈덩이를 던져 크기가 $0$이 되어도 눈덩이는 사라지지 않는다.

> 눈덩이가 앞마당의 끝에 도달한 경우 남은 시간과 관계없이 눈덩이 굴리기는 끝이 난다. 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 구하는 프로그램을 작성해보자.

# 입력
> 첫째 줄에 공백을 기준으로 앞마당의 길이 $N$ ($1 \leq N \leq 100$), 대회의 시간 $M$ ($1 \leq M \leq 10$)이 주어진다.
> 둘째 줄에 길이가 $N$인 수열 $a$가 주어진다. ($1 \leq a_i \leq 1\,000\,000$)

# 출력
> 첫째 줄에 대회 시간 내에 가장 크게 만들 수 있는 눈덩이의 크기를 출력한다.

# 풀이
눈덩이의 시작위치가 중요했는데 배열의 값을 0부터 넣어놓고 풀어보니 값이 더 크게 나와서 시작위치를 0으로 조절하고 배열의 값의 시작은 인덱스 1부터 시작하는 것으로 수정했더니 제대로된 답을 계산할 수 있었다.

# 코드
```c++
#include <iostream>
#include <algorithm>

using namespace std;

int N, M;

int arr[100] = {};

const int INF = 987654321;

int ans = -INF;

void DFS(int depth, int t, int size)
{
	if (depth > N || t >= M)
	{
		ans = max(ans, size);
		
		return;
	}

	if (depth <= N)
	{
		size += arr[depth + 1];
		DFS(depth + 1, t + 1, size);
		size -= arr[depth + 1];
	}

	if (depth <= N - 2)
	{
		int prev_size = size;
		size /= 2;
		size += arr[depth + 2];
		DFS(depth + 2, t + 1, size);
		size = prev_size;
	}
}

int main()
{
	cin >> N >> M;

    // 값은 1번부터 시작
	for (int i = 1; i <= N; i++)
	{
		cin >> arr[i];
	}

    // 0번 부터시작
	DFS(0, 0, 1);

	cout << ans << "\n";

	return 0;
}
```