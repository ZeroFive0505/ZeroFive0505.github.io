---
layout: post
title: 김인천씨의 식료품가게
date: 2022-07-25 08:40:29 +0900
categories: Baekjoon
---

## 문제 링크 -> [Baekjoon](https://www.acmicpc.net/problem/12033)
# 김인천씨의 식료품가게

# 문제
> 전설적인 인천 식료품가게의 주인인 김인천 씨는 대대적인 할인행사를 계획하고 있습니다. 계산을 단순하게하기 위해 그는 25% 할인된 가격으로 상점의 모든 품목을 판매하기로 결정했습니다. 즉, 각 품목의 판매 가격은 정상 가격의 정확히 75 %입니다. 우연하게도 인천 식료품가게에서 판매하는 모든 물건의 정상가는 4의 배수인 정수이고, 할인된 가격 역시 편리하게도 모두 정수입니다.
김인천씨는 이 할인행사를 준비하기위해서 먼저 모든 판매물품의 할인된 판매가격을 프린터로 출력을 실행했고, 또한 할인행사 종료후 다시 쓸 모든 품목에 정상가격표 역시 출력을 실행하였습니다.
손님이 찾아와 잠깐 자리를 비웠던 김인천씨가 다시 가격표의 출력을 확인하기 위해서 프린터로 돌아와보니, 공교롭게 프린터는 모든 물품의 할인가격과 정상가격을 따로 구분하지 않고 오름차순으로 정렬한 뒤 순서대로 출력하여 하나의 출력물 더미를 만들었습니다. 각 품목의 할인가격표와 정상가격표 모두가 출력물 더미의 어딘가에 있습니다. 그러나 두 유형(할인가격, 정상가격)의 가격표는 비슷하게 보이고, 모든 품목의 가격을 기억하지 못하기 때문에 김인천씨는 어느 가격표가 할인가격표인지 확신할 수 없습니다. 이 상황에서 김인천씨는 무엇이 할인가격표인지 구분해낼 수 있을까요?
예를 들어, 정상가격이 20, 80, 100 인 경우 할인가격은 15, 60, 75이며 프린터의 인쇄출력더미는 오름차순으로 정렬된 15, 20, 60, 75, 80, 100 가격표들로 구성됩니다.

# 입력
> 입력의 첫 번째 라인(줄)은 테스트 사례의 케이스의 수 T를 나타냅니다. 이후의 라인은 T개의 테스트 케이스가 이어집니다. 각 테스트 케이스는 두 줄로 구성됩니다. 첫 번째 줄에는 INU 식료품가게에 존재하는 상품수인 단일 정수 N이 포함됩니다. 두 번째 줄에는 프린터에서 가격의 오름차순으로 인쇄한 2N개의 정수 P1, P2, ..., P2N이 주어집니다.

> 입력값의 제한은 아래와 같습니다
> - 1 ≤ T ≤ 100.
> - 모든 i에 대해서 1 ≤ Pi ≤ 109.
> - 모든 i에 대해서 Pi ≤ Pi+1. (가격은 오름차순으로 존재)
> - 정답은 단 하나만 존재하는것이 보장되어 있음.
> - 1 ≤ N ≤ 4.

# 출력
> 개별 테스트 케이스에 대해서 출력라인은 “Case #x: y” 형식(큰 따옴표는 제외)으로 출력하며,  x는 1부터 시작하는 테스트 케이스의 번호 (인덱스)이며, y는 할인가격에 해당하는 오름차순으로 정렬된 N개의 정수들이다.

# 풀이
100%에서 계속 오답처리가 되서 한참을 고민했는데 long long으로 데이터 타입을 바꾸니 통과가 됬다... 10의 9승까지라 int로 충분하지 않을까 했는데 아니였다.. 아마 문제에서는 4의 배수인 정수라 이게 int의 범위를 아슬아슬하게 넘어간거 아닌가? 싶다.

일단 리스트를 2개를 이용해서 풀었다. 리스트 한곳에는 할인된 가격과 원래 가격이 섞인 리스트 다른 하나는 원래 가격과 세일된 가격의 짝을 찾고 찾았다면 체크하고 삭제할 리스트를 이용했다.

# 코드
```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <list>

using namespace std;

int T;
int N;

int main()
{
	cin >> T;

	for (int t = 1; t <= T; t++)
	{
		cin >> N;

		list<long long> l1;
		list<long long> l2;

		for (int i = 0; i < N * 2; i++)
		{
			long long num;

			cin >> num;

			l1.emplace_back(num);
			l2.emplace_back(num);
		}

		vector<long long> v;

		for (auto it = l1.begin(); it != l1.end(); it++)
		{   
			long long price = *it;

            // 만약 현재 가격이 4의 배수가 아니라면 일단 건너뛴다.
			if (price % 4 != 0)
				continue;

            // 세일된 가격을 계산한다.
			long long saled = (long long)(price * 0.75);

			auto saled_find = find_if(l2.begin(), l2.end(), [&saled](const long long n) {
				return saled == n;
			});

            // 만약 세일된 가격을 찾을 수 있었다면
			if (saled_find != l2.end())
			{
                // 정답에 기록
				v.emplace_back(saled);

                // 세일된 가격 삭제
				l2.erase(saled_find);

				auto price_find = find_if(l2.begin(), l2.end(), [&price](const long long n) {
					return price == n;
				});

                // 원래 가격도 삭제해준다.
				l2.erase(price_find);
			}
		}

		cout << "Case #" << t << ": ";

		for (size_t i = 0; i < v.size(); i++)
		{
			cout << v[i] << " ";
		}

		cout << "\n";
	}


	return 0;
}
```